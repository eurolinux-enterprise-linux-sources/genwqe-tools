diff --git a/.travis.yml b/.travis.yml
index 4157956..5d324e0 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,8 +3,14 @@ dist: trusty
 language: c
 compiler: gcc
 before_install:
+  - sudo dpkg --add-architecture i386
   - sudo apt-get -qq update
-  - sudo apt-get --assume-yes install gcc help2man git make zlib1g-dev
+  - sudo apt-cache search zlib
+  - sudo apt-get --assume-yes install gcc help2man git make zlib1g-dev libc6-dev-i386 zlib1g-dev:i386
+  - ls -l /usr/include/z*.h
 script:
-  - make
+  - make FORCE_32BIT=1 V=2 -j4
+  - make clean
+  - make -j4
   - make test_software
+  - make clean
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000..500eaad
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,28 @@
+Developer's Certificate of Origin 1.1
+
+       By making a contribution to this project, I certify that:
+
+       (a) The contribution was created in whole or in part by me and I
+           have the right to submit it under the open source license
+           indicated in the file; or
+
+       (b) The contribution is based upon previous work that, to the best
+           of my knowledge, is covered under an appropriate open source
+           license and I have the right under that license to submit that
+           work with modifications, whether created in whole or in part
+           by me, under the same open source license (unless I am
+           permitted to submit under a different license), as indicated
+           in the file; or
+
+       (c) The contribution was provided directly to me by some other
+           person who certified (a), (b) or (c) and I have not modified
+           it.
+
+       (d) I understand and agree that this project and the contribution
+           are public and that a record of the contribution (including all
+           personal information I submit with it, including my sign-off) is
+           maintained indefinitely and may be redistributed consistent with
+           this project or the open source license(s) involved.
+
+The developer sign-off should include the reference to the DCO (example below):
+DCO 1.1 Signed-off-by: Random J Developer <random@developer.org>
diff --git a/include/deflate_fifo.h b/include/deflate_fifo.h
index 5415c29..0bbe397 100644
--- a/include/deflate_fifo.h
+++ b/include/deflate_fifo.h
@@ -38,6 +38,10 @@
 #define ZEDC_FIFO_SIZE		256
 #define ZEDC_FIFO_MASK		(ZEDC_FIFO_SIZE - 1)
 
+#ifndef ARRAY_SIZE
+#  define ARRAY_SIZE(a)		(sizeof((a)) / sizeof((a)[0]))
+#endif
+
 struct zedc_fifo {
 	unsigned int	push;	/* push into FIFO here */
 	unsigned int	pop;	/* pop from FIFO here */
@@ -83,11 +87,11 @@ static inline int fifo_push32(struct zedc_fifo *fifo, uint32_t data)
 		uint8_t u8[4];
 	} d;
 
-	if (fifo_free(fifo) < 4)
+	if (fifo_free(fifo) < ARRAY_SIZE(d.u8))
 		return 0;
 
 	d.u32 = data;
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < ARRAY_SIZE(d.u8); i++) {
 		fifo->fifo[fifo->push] = d.u8[i];
 		fifo->push = (fifo->push + 1) & ZEDC_FIFO_MASK;
 	}
@@ -112,10 +116,10 @@ static inline int fifo_pop16(struct zedc_fifo *fifo, uint16_t *data)
 		uint8_t u8[2];
 	} d;
 
-	if (fifo_used(fifo) < 2)
+	if (fifo_used(fifo) < ARRAY_SIZE(d.u8))
 		return 0;
 
-	for (i = 0; i < 4; i++)
+	for (i = 0; i < ARRAY_SIZE(d.u8); i++)
 		fifo_pop(fifo, &d.u8[i]);
 
 	*data = d.u16;
diff --git a/lib/ddcb_capi.c b/lib/ddcb_capi.c
index 323b2ca..9289996 100644
--- a/lib/ddcb_capi.c
+++ b/lib/ddcb_capi.c
@@ -432,8 +432,9 @@ static int __afu_open(struct dev_ctx *ctx)
 	rc = cxl_get_cr_device(ctx->afu_h, 0, &ctx->cr_device);
 	if (rc == 0) {
 		if (ctx->cr_device != CGZIP_CR_DEVICE) {
-			VERBOSE0(" [%s] ERR: device_id: %ld/%d\n",
-				 __func__, (unsigned long)ctx->cr_device,
+			VERBOSE1(" [%s] WARNING: device_id: %ld/%d "
+				 "skipping, no CGZIP card\n", __func__,
+				 (unsigned long)ctx->cr_device,
 				 CGZIP_CR_VENDOR);
 			rc = DDCB_ERR_CARD;
 			goto err_afu_free;
diff --git a/lib/ddcb_card.c b/lib/ddcb_card.c
index d1ee60a..bffe230 100644
--- a/lib/ddcb_card.c
+++ b/lib/ddcb_card.c
@@ -109,7 +109,7 @@ static uint64_t _card_get_frequency(void *card_data)
 	if (speed >= ARRAY_SIZE(speed_grade))
 		return 0;       /* illegal value */
 
-	return speed_grade[speed] * 1000000;  /* in Hz */
+	return speed_grade[speed] * (uint64_t)1000000;  /* in Hz */
 }
 
 static void card_dump_hardware_version(void *card_data, FILE *fp)
diff --git a/lib/deflate.c b/lib/deflate.c
index f1e4ddf..4299878 100644
--- a/lib/deflate.c
+++ b/lib/deflate.c
@@ -292,6 +292,9 @@ int zedc_deflateSetDictionary(zedc_streamp strm,
 	if (dictLength > ZEDC_DICT_LEN)
 		return ZEDC_STREAM_ERROR;
 
+	if (dictionary == NULL)
+		return ZEDC_STREAM_ERROR;
+
 	memcpy(&strm->wsp->dict[0], dictionary, dictLength);
 	strm->dict_len = dictLength;
 	strm->dict_adler32 = __adler32(1, dictionary, dictLength);
diff --git a/lib/hardware.c b/lib/hardware.c
index f7631b7..e695118 100644
--- a/lib/hardware.c
+++ b/lib/hardware.c
@@ -99,8 +99,10 @@ static int zlib_xcheck = 1;
 static unsigned int zlib_ibuf_total = CONFIG_DEFLATE_BUF_SIZE;
 static unsigned int zlib_obuf_total = CONFIG_INFLATE_BUF_SIZE;
 
+#define ZEDC_CARDS_LENGTH 128
+
 /* Try to cache filehandles for faster access. Do not close them. */
-static zedc_handle_t zedc_cards[128 + 1];
+static zedc_handle_t zedc_cards[ZEDC_CARDS_LENGTH + 1];
 
 static zedc_handle_t __zedc_open(int card_no, int card_type, int mode,
 				 int *err_code)
@@ -112,15 +114,15 @@ static zedc_handle_t __zedc_open(int card_no, int card_type, int mode,
 				 err_code);
 
 	if (card_no == -1) {
-		if (zedc_cards[128])
-			return zedc_cards[128];
+		if (zedc_cards[ZEDC_CARDS_LENGTH])
+			return zedc_cards[ZEDC_CARDS_LENGTH];
 
-		zedc_cards[128] = zedc_open(card_no, card_type, mode,
+		zedc_cards[ZEDC_CARDS_LENGTH] = zedc_open(card_no, card_type, mode,
 					    err_code);
-		return zedc_cards[128];
+		return zedc_cards[ZEDC_CARDS_LENGTH];
 	}
 
-	if (card_no < 0 || card_no >= 128)
+	if (card_no < 0 || card_no >= ZEDC_CARDS_LENGTH)
 		return NULL;
 
 	if (zedc_cards[card_no] != NULL) {
@@ -169,11 +171,29 @@ static void stream_zlib_to_zedc(zedc_streamp h, z_streamp s)
 /**
  * Take care CRC/ADLER is correctly reported to the upper levels.
  */
-static void __fixup_crc_or_adler( z_streamp s, zedc_streamp h)
+static void __fixup_crc_or_adler(z_streamp s, zedc_streamp h)
 {
 	s->adler = (h->format == ZEDC_FORMAT_GZIP) ? h->crc32 : h->adler32;
 }
 
+/**
+ * See #152 The adler32 start value is 1 according to the specification.
+ * If there was a call to deflateSetDictionary() the adler field in s
+ * will be set to the adler32 value of the passed in dictionary.
+ * Nevertheless the data processing needs to start with a 1. This
+ * function takes are that on the 1st call of deflate when total_in
+ * is still 0, we set the start value always to 1.
+ */
+static void __prep_crc_or_adler(z_streamp s, zedc_streamp h)
+{
+	if (s->total_in == 0) {
+		if (h->format == ZEDC_FORMAT_ZLIB)
+			s->adler = 1;
+		else
+			s->adler = 0;
+	}
+}
+
 static void __free(void *ptr)
 {
 	if (ptr == NULL)
@@ -456,7 +476,10 @@ int h_deflateSetDictionary(z_streamp strm, const uint8_t *dictionary,
 	h = &s->h;
 
 	rc = zedc_deflateSetDictionary(h, dictionary, dictLength);
+	hw_trace("[%p]    adler32=%08x  dict_adler32=%08x\n", strm,
+		 h->adler32, h->dict_adler32);
 
+	strm->adler = h->dict_adler32; /* See #152 */
 	return rc_zedc_to_libz(rc);
 }
 
@@ -608,10 +631,11 @@ int h_deflate(z_streamp strm, int flush)
 		return s->rc;
 	}
 
+	__prep_crc_or_adler(strm, h);
 	hw_trace("[%p] h_deflate: flush=%s avail_in=%d avail_out=%d "
-		 "ibuf_avail=%d obuf_avail=%d\n",
+		 "ibuf_avail=%d obuf_avail=%d adler32/cr32=%08x/%08x\n",
 		 strm, flush_to_str(flush), strm->avail_in, strm->avail_out,
-		 (int)s->ibuf_avail, (int)s->obuf_avail);
+		 (int)s->ibuf_avail, (int)s->obuf_avail, h->adler32, h->crc32);
 
 	do {
 		hw_trace("[%p]   *** loop=%d flush=%s\n", strm, loops,
@@ -1291,7 +1315,7 @@ static inline int __check_stream_end(z_streamp strm)
  sync_avail_in:
 	/*
 	 * Only if we saw Z_STREAM_END and no problems understanding
-	 * the empty HUFFMAN or COPY_BLOCKs arised, we sync up the
+	 * the empty HUFFMAN or COPY_BLOCKs arose, we sync up the
 	 * stream.
 	 *
 	 * For DEFLATE and ZLIB we need to read the adler32 or
@@ -1671,7 +1695,7 @@ void zedc_hw_done(void)
 	if ((flags & ZLIB_FLAG_CACHE_HANDLES) == 0x0)
 		return;
 
-	for (card_no = 0; card_no <= 128; card_no++) {
+	for (card_no = 0; card_no <= ZEDC_CARDS_LENGTH; card_no++) {
 		if (zedc_cards[card_no] == NULL)
 			continue;
 		zedc_close(zedc_cards[card_no]);
diff --git a/lib/inflate.c b/lib/inflate.c
index e25fa7b..9e2762c 100644
--- a/lib/inflate.c
+++ b/lib/inflate.c
@@ -965,30 +965,30 @@ int zedc_inflateSaveBuffers(zedc_streamp strm, const char *prefix)
 		return rc;
 
 	snprintf(fname, sizeof(fname) - 1, "%s_out_buf.bin", prefix);
-	__save_buf_to_file(fname, (void *)(unsigned long)
-			   __be64_to_cpu(asiv->out_buff),
-			   __be32_to_cpu(asiv->out_buff_len));
+	rc = __save_buf_to_file(fname, (void *)(unsigned long)
+				__be64_to_cpu(asiv->out_buff),
+				__be32_to_cpu(asiv->out_buff_len));
 	if (rc != ZEDC_OK)
 		return rc;
 
 	snprintf(fname, sizeof(fname) - 1, "%s_in_dict.bin", prefix);
-	__save_buf_to_file(fname, (void *)(unsigned long)
-			   __be64_to_cpu(asiv->in_dict),
-			   __be32_to_cpu(asiv->in_dict_len));
+	rc = __save_buf_to_file(fname, (void *)(unsigned long)
+				__be64_to_cpu(asiv->in_dict),
+				__be32_to_cpu(asiv->in_dict_len));
 	if (rc != ZEDC_OK)
 		return rc;
 
 	snprintf(fname, sizeof(fname) - 1, "%s_out_dict.bin", prefix);
-	__save_buf_to_file(fname, (void *)(unsigned long)
-			   __be64_to_cpu(asiv->out_dict),
-			   __be32_to_cpu(asiv->out_dict_len));
+	rc = __save_buf_to_file(fname, (void *)(unsigned long)
+				__be64_to_cpu(asiv->out_dict),
+				__be32_to_cpu(asiv->out_dict_len));
 	if (rc != ZEDC_OK)
 		return rc;
 
 	snprintf(fname, sizeof(fname) - 1, "%s_inp_scratch.bin", prefix);
-	__save_buf_to_file(fname, (void *)(unsigned long)
-			   __be64_to_cpu(asiv->inp_scratch),
-			   __be32_to_cpu(asiv->in_scratch_len));
+	rc = __save_buf_to_file(fname, (void *)(unsigned long)
+				__be64_to_cpu(asiv->inp_scratch),
+				__be32_to_cpu(asiv->in_scratch_len));
 	if (rc != ZEDC_OK)
 		return rc;
 
diff --git a/lib/libcard.c b/lib/libcard.c
index b511730..d573b34 100644
--- a/lib/libcard.c
+++ b/lib/libcard.c
@@ -1062,10 +1062,10 @@ void genwqe_card_lib_debug(int onoff)
  */
 static void ddcb_setup_crc32(struct lib_data_t *d)
 {
-	int i, j;
+	unsigned int i, j;
 	uint32_t crc;
 
-	for (i = 0;  i < 256;  i++) {
+	for (i = 0;  i < ARRAY_SIZE(d->crc32_tab);  i++) {
 		crc = i << 24;
 		for (j = 0;  j < 8;  j++) {
 			if (crc & 0x80000000)
@@ -1364,9 +1364,9 @@ int genwqe_pin_memory(card_handle_t dev, const void *addr, size_t size,
 			if (0 == rc)
 				return GENWQE_OK;
 		}
+		pr_err("Dev: %p Fault: %d addr=%p size=%lld dir=%d\n", dev,
+				dev->drv_errno, addr, (long long)size, direction);
 	}
-	pr_err("Dev: %p Fault: %d addr=%p size=%lld dir=%d\n", dev,
-	       dev->drv_errno, addr, (long long)size, direction);
 	return GENWQE_ERR_PINNING;
 }
 
@@ -1390,9 +1390,9 @@ int genwqe_unpin_memory(card_handle_t dev, const void *addr, size_t size)
 			if (0 == rc)
 				return GENWQE_OK;
 		}
+		pr_err("Dev: %p Fault: %d addr=%p size=%lld\n", dev,
+				dev->drv_errno, addr, (long long)size);
 	}
-	pr_err("Dev: %p Fault: %d addr=%p size=%lld\n", dev,
-	       dev->drv_errno, addr, (long long)size);
 	return GENWQE_ERR_PINNING;
 }
 
@@ -1642,20 +1642,18 @@ static void __hexdump(FILE *fp, const void *buff, unsigned int size)
  */
 void genwqe_hexdump(FILE *fp, const void *buff, unsigned int size)
 {
-	unsigned int i;
+	unsigned int i, j = 0;
 	const uint8_t *b = (uint8_t *)buff;
 	char ascii[17];
-	char str[2] = { 0x0, };
 
 	for (i = 0; i < size; i++) {
 		if ((i & 0x0f) == 0x00) {
 			fprintf(fp, " %08x:", i);
-			memset(ascii, 0, sizeof(ascii));
+			memset(ascii, '\0', sizeof(ascii));
+			j = 0;
 		}
 		fprintf(fp, " %02x", b[i]);
-		str[0] = isalnum(b[i]) ? b[i] : '.';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = isalnum(b[i]) ? b[i] : '.';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
@@ -1664,9 +1662,7 @@ void genwqe_hexdump(FILE *fp, const void *buff, unsigned int size)
 	/* print trailing up to a 16 byte boundary. */
 	for (; i < ((size + 0xf) & ~0xf); i++) {
 		fprintf(fp, "   ");
-		str[0] = ' ';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = ' ';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
@@ -1737,8 +1733,10 @@ int genwqe_flash_read(card_handle_t dev, struct card_upd_params *upd)
 	rc = __genwqe_flash_read(dev, upd->partition, buf, buflen,
 				 &upd->retc, &upd->attn,
 				 &upd->progress);
-	if (rc < 0)
+	if (rc < 0) {
+		close(fd);
 		goto err_exit;
+	}
 
 	rc = (int)write(fd, buf, (size_t)upd->flength);
 	close(fd);
diff --git a/lib/libddcb.c b/lib/libddcb.c
index 4e94b5e..251e27e 100644
--- a/lib/libddcb.c
+++ b/lib/libddcb.c
@@ -150,10 +150,9 @@ const char *ddcb_strerror(int errnum)
 
 void ddcb_hexdump(FILE *fp, const void *buff, unsigned int size)
 {
-	unsigned int i;
+	unsigned int i, j = 0;
 	const uint8_t *b = (uint8_t *)buff;
 	char ascii[17];
-	char str[2] = { 0x0, };
 
 	if (fp == NULL)
 		return;
@@ -161,12 +160,11 @@ void ddcb_hexdump(FILE *fp, const void *buff, unsigned int size)
 	for (i = 0; i < size; i++) {
 		if ((i & 0x0f) == 0x00) {
 			fprintf(fp, " %08x:", i);
-			memset(ascii, 0, sizeof(ascii));
+			memset(ascii, '\0', sizeof(ascii));
+			j = 0;
 		}
 		fprintf(fp, " %02x", b[i]);
-		str[0] = isalnum(b[i]) ? b[i] : '.';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = isalnum(b[i]) ? b[i] : '.';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
@@ -175,9 +173,7 @@ void ddcb_hexdump(FILE *fp, const void *buff, unsigned int size)
 	/* print trailing up to a 16 byte boundary. */
 	for (; i < ((size + 0xf) & ~0xf); i++) {
 		fprintf(fp, "   ");
-		str[0] = ' ';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = ' ';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
@@ -534,7 +530,7 @@ int ddcb_register_accelerator(struct ddcb_accel_funcs *accel)
 	if (accel == NULL)
 		return DDCB_ERR_INVAL;
 
-	if ddcb_gather_statistics() {
+	if (ddcb_gather_statistics()) {
 		rc = pthread_mutex_init(&accel->slock, NULL);
 		if (rc != 0)
 			return DDCB_ERRNO;
diff --git a/lib/wrapper.c b/lib/wrapper.c
index 2e93f71..c16fbf7 100644
--- a/lib/wrapper.c
+++ b/lib/wrapper.c
@@ -626,6 +626,9 @@ int deflateSetDictionary(z_streamp strm,
 	strm->state = w->priv_data;
 	rc = w->impl ? h_deflateSetDictionary(strm, dictionary, dictLength) :
 		       z_deflateSetDictionary(strm, dictionary, dictLength);
+	
+	pr_trace("[%p]    calculated adler32=%08x\n", strm,
+		 (unsigned int)strm->adler);
 	strm->state = (void *)w;
 
 	return rc;
@@ -845,9 +848,10 @@ int deflateEnd(z_streamp strm)
 	}
 
 	rc = __deflateEnd(strm, w);
-	free(w);
 
 	pr_trace("[%p] deflateEnd w=%p rc=%d\n", strm, w, rc);
+	free(w);
+
 	return rc;
 }
 
@@ -1302,9 +1306,10 @@ int inflateEnd(z_streamp strm)
 		free(w->dictionary);
 		w->dictionary = NULL;
 	}
-	free(w);
 
 	pr_trace("[%p] inflateEnd w=%p rc=%d\n", strm, w, rc);
+	free(w);
+
 	return rc;
 }
 
diff --git a/licenses/cla-corporate.txt b/licenses/cla-corporate.txt
deleted file mode 100644
index d137017..0000000
--- a/licenses/cla-corporate.txt
+++ /dev/null
@@ -1,157 +0,0 @@
-        International Business machines, Inc.
-  Software Grant and Corporate Contributor License Agreement ("Agreement")
-        http://www.github.org/ibm-genwqe/licenses/
-
-
-Thank you for your interest in IBM’s ibm-genwqe project (“Hardware
-acceleration of deflate/zlib compression with IBM FPGA
-accelerators"). In order to clarify the intellectual property license
-granted with Contributions from any person or entity, IBM must have a
-Contributor License Agreement (CLA) on file that has been signed by
-each Contributor, indicating agreement to the license terms
-below. This license is for your protection as a Contributor as well as
-the protection of IBM and its users; it does not change your rights to
-use your own Contributions for any other purpose.
-
-This version of the Agreement allows an entity (the "Corporation") to
-submit Contributions to the Project, to authorize Contributions
-submitted by its designated employees to the Project, and to grant
-copyright and patent licenses thereto.
-   
-If you have not already done so, please complete and sign, then scan
-and email a pdf file of this Agreement to <haverkam@de.ibm.com>. If
-necessary, send an original signed Agreement to:
-
-IBM Deutschland RD GmbH 
-SCHOENAICHER STR. 220, BOEBLINGEN 71032
-Germany
-Attn: Frank Haverkamp
-
-
-   Please read this document carefully before signing and keep a copy
-   for your records.
-
-Corporation name:    ________________________________________________
-      
-Corporation address: ________________________________________________
-
-                     ________________________________________________
-
-Point of Contact:    ________________________________________________
-
-E-Mail:              ________________________________________________
-
-Telephone:           _____________________ 
-      
-
-You accept and agree to the following terms and conditions for Your
-present and future Contributions submitted to the Project. Except for
-the license granted herein to IBM and recipients of software
-distributed by IBM, You reserve all right, title, and interest in and
-to Your Contributions.
-
-1. Definitions.
-
-   "You" (or "Your") shall mean the copyright owner or legal entity
-   authorized by the copyright owner that is making this Agreement
-   with IBM. For legal entities, the entity making a Contribution and    
-   all other entities that control, are controlled by, or are under 
-   common control with that entity are considered to be a single    
-   Contributor. For the purposes of this definition, "control" means    
-   (i) the power, direct or indirect, to cause the direction or
-   management of such entity, whether by contract or otherwise, or
-   (ii) ownership of fifty percent (50%) or more of the outstanding
-   shares, or (iii) beneficial ownership of such entity.
-
-   "Contribution" shall mean the code, documentation or other original
-   works of authorship expressly identified in Schedule B, as well as
-   any original work of authorship, including any modifications or
-   additions to an existing work, that is intentionally submitted by
-   You to IBM for inclusion in, or documentation of, the Project
-   managed by IBM (the "Work"). For the purposes of this definition,
-   "submitted" means any form of electronic, verbal, or written
-   communication sent to IBM or its representatives, including but not
-   limited to communication on electronic mailing lists, source code
-   control systems, and issue tracking systems that are managed by, or
-   on behalf of, IBM for the purpose of discussing and improving the
-   Work, but excluding communication that is conspicuously marked or
-   otherwise designated in writing by You as "Not a Contribution."
-
-2. Grant of Copyright License. Subject to the terms and conditions
-   of this Agreement, You hereby grant to IBM and to
-   recipients of software distributed by IBM a perpetual,
-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-   copyright license to reproduce, prepare derivative works of,
-   publicly display, publicly perform, sublicense, and distribute
-   Your Contributions and such derivative works.
-
-3. Grant of Patent License. Subject to the terms and conditions of
-   this Agreement, You hereby grant to IBM and to recipients
-   of software distributed by IBM a perpetual, worldwide,
-   non-exclusive, no-charge, royalty-free, irrevocable (except as
-   stated in this section) patent license to make, have made, use,
-   offer to sell, sell, import, and otherwise transfer the Work,
-   where such license applies only to those patent claims licensable
-   by You that are necessarily infringed by Your Contribution(s)
-   alone or by combination of Your Contribution(s) with the Work to
-   which such Contribution(s) were submitted. If any entity institutes
-   patent litigation against You or any other entity (including a
-   cross-claim or counterclaim in a lawsuit) alleging that your
-   Contribution, or the Work to which you have contributed, constitutes
-   direct or contributory patent infringement, then any patent licenses
-   granted to that entity under this Agreement for that Contribution or
-   Work shall terminate as of the date such litigation is filed.
-
-4. You represent that You are legally entitled to grant the above
-   license. You represent further that each employee of the
-   Corporation designated on Schedule A below (or in a subsequent
-   written modification to that Schedule) is authorized to submit
-   Contributions on behalf of the Corporation.
-
-5. You represent that each of Your Contributions is Your original
-   creation (see section 7 for submissions on behalf of others).
-
-6. You are not expected to provide support for Your Contributions,
-   except to the extent You desire to provide support. You may provide
-   support for free, for a fee, or not at all. Unless required by
-   applicable law or agreed to in writing, You provide Your
-   Contributions on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
-   OF ANY KIND, either express or implied, including, without
-   limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT,
-   MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.
-
-7. Should You wish to submit work that is not Your original creation,
-   You may submit it to IBM separately from any
-   Contribution, identifying the complete details of its source and
-   of any license or other restriction (including, but not limited
-   to, related patents, trademarks, and license agreements) of which
-   you are personally aware, and conspicuously marking the work as
-   "Submitted on behalf of a third-party: [named here]".
-
-8. It is your responsibility to notify IBM when any change
-   is required to the list of designated employees authorized to submit
-   Contributions on behalf of the Corporation, or to the Corporation's
-   Point of Contact with IBM.
-
-
-
-Please sign: __________________________________ Date: _______________
-
-Title:       __________________________________
-
-Corporation: __________________________________
-
-
-Schedule A
-
-   [Initial list of designated employees.  NB: authorization is not
-    tied to particular Contributions.]
-
-
-
-
-Schedule B
-
-   [Identification of optional concurrent software grant.  Would be
-    left blank or omitted if there is no concurrent software grant.]
-
diff --git a/licenses/cla-individual.txt b/licenses/cla-individual.txt
deleted file mode 100644
index 56aad29..0000000
--- a/licenses/cla-individual.txt
+++ /dev/null
@@ -1,140 +0,0 @@
-        International Business Machines, Inc. (IBM)
-     Individual Contributor License Agreement ("Agreement")
-        http://www.github.org/ibm-genwqe/licenses/
-
-Thank you for your interest in the ibm-genwqe project ("Hardware
-acceleration of deflate/zlib compression with IBM FPGA accelerators").
-
-In order to clarify the intellectual property license granted with
-Contributions from any person or entity, IBM must have a Contributor
-License Agreement ("CLA") on file that has been signed by each
-Contributor, indicating agreement to the license terms below. This
-license is for your protection as a Contributor as well as the
-protection of IBM and its customers; it does not change your rights to
-use your own Contributions for any other purpose.  If you have not
-already done so, please complete and sign, then scan and email a pdf
-file of this Agreement to <haverkam@de.ibm.com>.
-
-The original signed agreement should be sent to:
-
-IBM Deutschland RD GmbH 
-SCHOENAICHER STR. 220, BOEBLINGEN 71032
-Germany
-Attn: Frank Haverkamp
-
-Please read this document carefully before signing and keep a copy for
-your records.
-
-  Full name: ______________________________________________________
-
-  (optional) Public name: _________________________________________
-
-  Mailing Address: ________________________________________________
-
-                   ________________________________________________
-
-  Country:   ______________________________________________________
-
-  Telephone: ______________________________________________________
-
-  E-Mail:    ______________________________________________________
-
-
-You accept and agree to the following terms and conditions for Your
-present and future Contributions submitted to the Project. Except for
-the license granted herein to IBM and recipients of software
-distributed by IBM, You reserve all right, title, and interest in and
-to Your Contributions.
-
-1. Definitions.
-
-   "You" (or "Your") shall mean the copyright owner or legal entity
-   authorized by the copyright owner that is making this Agreement
-   with IBM. For legal entities, the entity making a Contribution and
-   all other entities that control, are controlled by, or are under
-   common control with that entity are considered to be a single
-   Contributor. For the purposes of this definition, "control" means
-   (i) the power, direct or indirect, to cause the direction or
-   management of such entity, whether by contract or otherwise, or
-   (ii) ownership of fifty percent (50%) or more of the outstanding
-   shares, or (iii) beneficial ownership of such entity.
-
-   "Contribution" shall mean any original work of authorship,
-   including any modifications or additions to an existing work, that
-   is intentionally submitted by You to the Project for inclusion in,
-   or documentation of, the Project (”the Work”). For the purposes of
-   this definition, "submitted" means any form of electronic, verbal,
-   or written communication sent to the Project or its
-   representatives,including but not limited to communication on
-   electronic mailing lists, source code control systems, and issue
-   tracking systems that are managed by, or on behalf of, the Project
-   for the purpose of discussing and improving the Work, but excluding
-   communication that is conspicuously marked or otherwise designated
-   in writing by You as "Not a Contribution."
-
-2. Grant of Copyright License. Subject to the terms and conditions of
-   this Agreement, You hereby grant to IBM and to recipients of software
-   distributed by IBM a perpetual, worldwide, non-exclusive, no-charge,
-   royalty-free, irrevocable copyright license to reproduce, prepare
-   derivative works of, publicly display, publicly perform, sublicense,
-   and distribute Your Contributions and such derivative works.
-
-3. Grant of Patent License. Subject to the terms and conditions of
-   this Agreement, You hereby grant to IBM and to recipients of software
-   distributed by IBM a perpetual, worldwide, non-exclusive, no-charge,
-   royalty-free, irrevocable (except as stated in this section) patent
-   license to make, have made, use, offer to sell, sell, import, and
-   otherwise transfer the Work to which Your Contribution(s) were
-   submitted, where such license applies only to those patent claims
-   licensable by You that are necessarily infringed by Your
-   Contribution(s) alone or by combination of Your Contribution(s) with
-   the Work to which such Contribution(s) was submitted. If any entity
-   institutes patent litigation against You or any other entity
-   (including a cross-claim or counterclaim in a lawsuit) alleging that
-   your Contribution, or the Work to which you have contributed,
-   constitutes direct or contributory patent infringement, then any
-   patent licenses granted to that entity under this Agreement for that
-   Contribution or Work shall terminate as of the date such litigation is
-   filed.
-
-4. You represent that you are legally entitled to grant the above
-   license. If your employer(s) has rights to intellectual property
-   that you create that includes your Contributions, you represent
-   that you have received permission to make Contributions on behalf
-   of that employer, that your employer has waived such rights for
-   your Contributions to the Project, or that your employer has
-   executed a separate Corporate CLA with IBM.
-
-5. You represent that each of Your Contributions is Your original
-   creation (see section 7 for submissions on behalf of others).  You
-   represent that Your Contribution submissions include complete
-   details of any third-party license or other restriction (including,
-   but not limited to, related patents and trademarks) of which you
-   are personally aware and which are associated with any part of Your
-   Contributions.
-
-6. You are not expected to provide support for Your Contributions,
-   except to the extent You desire to provide support. You may provide
-   support for free, for a fee, or not at all. Unless required by
-   applicable law or agreed to in writing, You provide Your
-   Contributions on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
-   OF ANY KIND, either express or implied, including, without
-   limitation, any warranties or conditions of TITLE, NON-
-   INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.
-
-7. Should You wish to submit work that is not Your original creation,
-   You may submit it to the Project separately from any
-   Contribution, identifying the complete details of its source and of
-   any license or other restriction (including, but not limited to,
-   related patents, trademarks, and license agreements) of which you
-   are personally aware, and conspicuously marking the work as
-   "Submitted on behalf of a third-party: [named here]".
-
-8. You agree to notify IBM of any facts or circumstances of
-   which you become aware that would make these representations
-   inaccurate in any respect.
-
-
-
-Please sign: __________________________________ Date: ________________
-
diff --git a/misc/zlib_test.sh b/misc/zlib_test.sh
index ec031f7..ddc6271 100755
--- a/misc/zlib_test.sh
+++ b/misc/zlib_test.sh
@@ -397,7 +397,7 @@ function zlib_append ()
     local params=$2
 
     # Use default settings ...
-    # Set size large enough that hardware inflate is realy used
+    # Set size large enough that hardware inflate is really used
     #
     # hhh [0x3ffff1c655d8] loops=0 flush=1 Z_PARTIAL_FLUSH
     # hhh [0x3ffff1c655d8] *** giving out 100 bytes ...
diff --git a/misc/zpipe_append.c b/misc/zpipe_append.c
index 7cb2e2d..7f75a7b 100644
--- a/misc/zpipe_append.c
+++ b/misc/zpipe_append.c
@@ -100,7 +100,7 @@ static int def(FILE *source, FILE *dest, int window_bits, int _flush,
 		return Z_ERRNO;
 
 	out = malloc(CHUNK_o);
-	if (in == NULL) {
+	if (out == NULL) {
 		free(in);
 		return Z_ERRNO;
 	}
@@ -113,8 +113,11 @@ static int def(FILE *source, FILE *dest, int window_bits, int _flush,
 
 	ret = deflateInit2(&strm, level, Z_DEFLATED, window_bits, 8,
 			   Z_DEFAULT_STRATEGY);
-	if (ret != Z_OK)
+	if (ret != Z_OK) {
+		free(in);
+		free(out);
 		return ret;
+	}
 
 	/* compress until end of file */
 	do {
@@ -210,7 +213,7 @@ static int inf(FILE *source, FILE *dest, int window_bits, int _flush,
 		return Z_ERRNO;
 
 	out = malloc(CHUNK_o);
-	if (in == NULL) {
+	if (out == NULL) {
 		free(in);
 		return Z_ERRNO;
 	}
@@ -503,6 +506,8 @@ int main(int argc, char **argv)
 	rc = def(i_fp, o_fp, window_bits, flush, Z_DEFAULT_COMPRESSION,
 		 &expected_bytes, &decompressed_bytes);
 	if (rc != Z_OK) {
+		fclose(o_fp);
+		fclose(i_fp);
 		fprintf(stderr, "err: compression failed.\n");
 		zerr(rc);
 		return rc;
@@ -566,6 +571,8 @@ int main(int argc, char **argv)
 	}
 
 	if (rc != Z_OK) {
+		fclose(o_fp);
+		fclose(n_fp);
 		fprintf(stderr, "err: decompression failed.\n");
 		zerr(rc);
 		return rc;
diff --git a/misc/zpipe_mt.c b/misc/zpipe_mt.c
index 03c57a1..27344f6 100644
--- a/misc/zpipe_mt.c
+++ b/misc/zpipe_mt.c
@@ -42,7 +42,7 @@
 #  define SET_BINARY_MODE(file)
 #endif
 
-/* FIXME Fake this for old RHEL verions e.g. RHEL5.6 */
+/* FIXME Fake this for old RHEL versions e.g. RHEL5.6 */
 #ifndef CPU_ALLOC
 #define	  CPU_ALLOC(cpus)		      ({ void *ptr = NULL; ptr; })
 #define	  CPU_ALLOC_SIZE(cpus)		      ({ int val = 0; val; })
@@ -54,7 +54,7 @@
 #define	  sched_setaffinity(x, size, cpusetp) ({ int val = 0; val; })
 #endif
 
-/* FIXME Fake this for old RHEL verions e.g. RHEL5.6 */
+/* FIXME Fake this for old RHEL versions e.g. RHEL5.6 */
 #ifndef CLOCK_MONOTONIC_RAW
 #define   clock_gettime(clk_id, tp) ({ int val = 0; val; })
 #endif
diff --git a/misc/zpipe_rnd.c b/misc/zpipe_rnd.c
index 042cbc1..ee8e3eb 100644
--- a/misc/zpipe_rnd.c
+++ b/misc/zpipe_rnd.c
@@ -48,8 +48,8 @@ static unsigned int CHUNK_o = 4 * 1024 * 1024; /* 16384; */
    level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
    version of the library linked do not match, or Z_ERRNO if there is
    an error reading or writing the files. */
-static int def(FILE *source, FILE *dest, int level, int windowBits,
-	       uint8_t *dictionary, int dictLength)
+static int def(FILE *source, FILE *dest, int level, int strategy,
+	       int windowBits, uint8_t *dictionary, int dictLength)
 {
 	int ret, flush;
 	unsigned have;
@@ -64,22 +64,30 @@ static int def(FILE *source, FILE *dest, int level, int windowBits,
 		return Z_ERRNO;
 
 	out = malloc(CHUNK_o);
-	if (out == NULL)
+	if (out == NULL) {
+		free(in);
 		return Z_ERRNO;
+	}
 
 	/* allocate deflate state */
 	strm.zalloc = Z_NULL;
 	strm.zfree = Z_NULL;
 	strm.opaque = Z_NULL;
 	ret = deflateInit2(&strm, level, Z_DEFLATED, windowBits, 8,
-			   Z_DEFAULT_STRATEGY);
-	if (ret != Z_OK)
+			   strategy);
+	if (ret != Z_OK) {
+		free(in);
+		free(out);
 		return ret;
+	}
 
 	if (dictLength > 0) {
 		ret = deflateSetDictionary(&strm, dictionary, dictLength);
-		if (ret != Z_OK)
+		if (ret != Z_OK) {
+			free(in);
+			free(out);
 			return ret;
+		}
 	}
 
 	/* compress until end of file */
@@ -152,8 +160,10 @@ static int inf(FILE *source, FILE *dest, int windowBits,
 		return Z_ERRNO;
 
 	out = malloc(CHUNK_o);
-	if (out == NULL)
+	if (out == NULL) {
+		free(in);
 		return Z_ERRNO;
+	}
 
 	/* allocate inflate state */
 	strm.zalloc = Z_NULL;
@@ -163,14 +173,20 @@ static int inf(FILE *source, FILE *dest, int windowBits,
 	strm.next_in = Z_NULL;
 
 	ret = inflateInit2(&strm, windowBits);
-	if (ret != Z_OK)
+	if (ret != Z_OK) {
+		free(in);
+		free(out);
 		return ret;
+	}
 
 	if (!((windowBits >= 8) && (windowBits <= 15)) &&  /* !ZLIB */
 	    (dictLength > 0)) {
 		ret = inflateSetDictionary(&strm, dictionary, dictLength);
-		if (ret != Z_OK)
+		if (ret != Z_OK) {
+			free(in);
+			free(out);
 			return ret;
+		}
 	}
 
 	/* decompress until deflate stream ends or end of file */
@@ -306,6 +322,8 @@ static void usage(char *prog)
 
 	fprintf(stderr, "%s usage: %s [-d, --decompress]\n"
 		"    [-F, --format <ZLIB|DEFLATE|GZIP>]\n"
+		"    [-S, --strategy <0..4>] 0: DEFAULT,\n"
+		"      1: FILTERED, 2: HUFFMAN_ONLY, 3: RLE, 4: FIXED\n"
 		"    [-r, --rnd\n"		
 		"    [-s, --seed <seed>\n"		
 		"    [-1, --fast]\n"
@@ -369,6 +387,7 @@ int main(int argc, char **argv)
 	int dictLength = 0;
 	int windowBits;
 	int level = Z_DEFAULT_COMPRESSION;
+	int strategy = Z_DEFAULT_STRATEGY;
 
 	/* avoid end-of-line conversions */
 	SET_BINARY_MODE(stdin);
@@ -379,6 +398,7 @@ int main(int argc, char **argv)
 		int option_index = 0;
 		static struct option long_options[] = {
 			{ "decompress",  no_argument,       NULL, 'd' },
+			{ "strategy",	 required_argument, NULL, 'S' },
 			{ "format",	 required_argument, NULL, 'F' },
 			{ "fast",        no_argument,       NULL, '1' },
 			{ "default",     no_argument,       NULL, '6' },
@@ -393,7 +413,7 @@ int main(int argc, char **argv)
 			{ 0,		 no_argument,       NULL, 0   },
 		};
 
-		ch = getopt_long(argc, argv, "169D:F:rs:i:o:dvh?",
+		ch = getopt_long(argc, argv, "169D:F:rs:i:o:S:dvh?",
 				 long_options, &option_index);
 		if (ch == -1)    /* all params processed ? */
 			break;
@@ -427,6 +447,9 @@ int main(int argc, char **argv)
 		case 's':
 			seed = str_to_num(optarg);
 			break;
+		case 'S':
+			strategy = str_to_num(optarg);
+			break;
 		case 'i':
 			CHUNK_i = str_to_num(optarg);
 			break;
@@ -447,7 +470,8 @@ int main(int argc, char **argv)
 
 	/* do compression if no arguments */
 	if (compress == 1) {
-		ret = def(stdin, stdout, level, windowBits, dictionary, dictLength);
+		ret = def(stdin, stdout, level, strategy,
+			  windowBits, dictionary, dictLength);
 		if (ret != Z_OK)
 			zerr(ret);
 		return ret;
diff --git a/tools/Makefile b/tools/Makefile
index 4d14b10..cefdcdd 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -62,7 +62,9 @@ $(projs): $(libs)
 
 objs = force_cpu.o genwqe_vpd_common.o $(projs:=.o)
 
-manpages = $(projs:=.1.gz)
+test_scripts = genwqe_mt_perf genwqe_test_gz
+
+manpages = $(projs:=.1.gz) $(test_scripts:=.1.gz)
 
 manpages: all $(manpages)
 
@@ -83,6 +85,7 @@ genwqe_gunzip.o: genwqe_gzip.c
 ### Setting LD_LIBRARY_PATH helps to try tools with dynamic linkage
 %.1: %
 	LD_LIBRARY_PATH=../lib $(HELP2MAN) -N --output=$@ \
+		--help-option='-h' --version-option='-V' \
 		--name "IBM Hardware Accelerator Tool." ./$<
 
 %.1.gz: %.1
diff --git a/tools/force_cpu.c b/tools/force_cpu.c
index eb1634b..0f8cb4c 100644
--- a/tools/force_cpu.c
+++ b/tools/force_cpu.c
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2017 International Business Machines
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/tools/genwqe_echo.c b/tools/genwqe_echo.c
index 449564d..8386a9e 100644
--- a/tools/genwqe_echo.c
+++ b/tools/genwqe_echo.c
@@ -75,7 +75,6 @@ static void usage(const char *prog)
 	       "  -i, --interval=INTERVAL_USEC\n"
 	       "  -s, --string=TESTSTRING\n"
 	       "  -p, --polling          use DDCB polling mode.\n"
-	       "  -q, --quiet            only summary output\n"
 	       "\n"
 	       "This utility sends echo DDCBs either to the service layer\n"
 	       "or other chip units. It can be used to check the cards\n"
diff --git a/tools/genwqe_find_card b/tools/genwqe_find_card
index ca60040..aedb07a 100755
--- a/tools/genwqe_find_card
+++ b/tools/genwqe_find_card
@@ -25,6 +25,14 @@
 
 export accel=UNKNOWN
 
+# Print usage message helper function
+function usage() {
+	echo "Usage of $PROGRAM:"
+	echo "    [-A] <accelerator> use either GENWQE for the PCIe "
+	echo "         and CAPI for CAPI based solution available "
+	echo "         only on System p"
+}
+
 # Parse any options given on the command line
 while getopts "A:C:t:PvVhl" opt; do
 	case ${opt} in
@@ -46,14 +54,6 @@ while getopts "A:C:t:PvVhl" opt; do
 	esac
 done
 
-# Print usage message helper function
-function usage() {
-	echo "Usage of $PROGRAM:"
-	echo "    [-A] <accelerator> use either GENWQE for the PCIe "
-	echo "         and CAPI for CAPI based solution available "
-	echo "         only on System p"
-}
-
 #
 # We need to take into account that there might be other CAPI cards
 # in our system. Therefore we check the psl_revision, which identifies
diff --git a/tools/genwqe_gzip.c b/tools/genwqe_gzip.c
index d2990d3..9df40ef 100644
--- a/tools/genwqe_gzip.c
+++ b/tools/genwqe_gzip.c
@@ -368,10 +368,9 @@ static void usage(FILE *fp, char *prog, int argc, char *argv[])
 
 static inline void hexdump(FILE *fp, const void *buff, unsigned int size)
 {
-	unsigned int i;
+	unsigned int i, j = 0;
 	const uint8_t *b = (uint8_t *)buff;
 	char ascii[17];
-	char str[2] = { 0x0, };
 
 	if (size == 0)
 		return;
@@ -379,12 +378,11 @@ static inline void hexdump(FILE *fp, const void *buff, unsigned int size)
 	for (i = 0; i < size; i++) {
 		if ((i & 0x0f) == 0x00) {
 			fprintf(fp, " %08x:", i);
-			memset(ascii, 0, sizeof(ascii));
+			memset(ascii, '\0', sizeof(ascii));
+			j = 0;
 		}
 		fprintf(fp, " %02x", b[i]);
-		str[0] = isalnum(b[i]) ? b[i] : '.';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = isalnum(b[i]) ? b[i] : '.';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
@@ -393,9 +391,7 @@ static inline void hexdump(FILE *fp, const void *buff, unsigned int size)
 	/* print trailing up to a 16 byte boundary. */
 	for (; i < ((size + 0xf) & ~0xf); i++) {
 		fprintf(fp, "   ");
-		str[0] = ' ';
-		str[1] = '\0';
-		strncat(ascii, str, sizeof(ascii) - 1);
+		ascii[j++] = ' ';
 
 		if ((i & 0x0f) == 0x0f)
 			fprintf(fp, " | %s\n", ascii);
diff --git a/tools/genwqe_memcopy.c b/tools/genwqe_memcopy.c
index 1222cdd..7d25391 100644
--- a/tools/genwqe_memcopy.c
+++ b/tools/genwqe_memcopy.c
@@ -746,7 +746,7 @@ int main(int argc, char *argv[])
 				break;
 			}
 			ip.card_type = strtol(optarg, (char **)NULL, 0);
-			if ((DDCB_TYPE_GENWQE != ip.card_type) ||
+			if ((DDCB_TYPE_GENWQE != ip.card_type) &&
 				(DDCB_TYPE_CAPI != ip.card_type)) {
 				usage(argv[0]);
 				exit(EXIT_FAILURE);
diff --git a/tools/genwqe_vpd_common.c b/tools/genwqe_vpd_common.c
index d6d27d0..4c98906 100644
--- a/tools/genwqe_vpd_common.c
+++ b/tools/genwqe_vpd_common.c
@@ -49,10 +49,10 @@ static char crc_token[]={"CS"};
 
 void genwqe_crc32_setup_lut(void)
 {
-	int i, j;
+	unsigned int i, j;
 	uint32_t crc;
 
-	for (i = 0;  i < 256;  i++) {
+	for (i = 0;  i < ARRAY_SIZE(genwqe_crc32_lut);  i++) {
 		crc = i << 24;
 		for ( j = 0;  j < 8;  j++ ) {
 			if (crc & 0x80000000)
diff --git a/tools/gzFile_test.c b/tools/gzFile_test.c
index 348d3fc..19b56cb 100644
--- a/tools/gzFile_test.c
+++ b/tools/gzFile_test.c
@@ -557,6 +557,11 @@ int main(int argc, char **argv)
 		exit(EXIT_FAILURE);
 	}
 
+	if ((i_fname == NULL) || (o_fname == NULL)) {
+		pr_err("No input or output file name provided.");
+		return -1;
+        }
+
 	fprintf(stderr, "%sCompress %s to %s in %ld bytes, "
 		"out %ld bytes chunks with level %d (size=%lld, offs=%lld)\n",
 		use_compress ? "" : "De",
diff --git a/tools/zlib_mt_perf.c b/tools/zlib_mt_perf.c
index e90e824..dff5a0f 100644
--- a/tools/zlib_mt_perf.c
+++ b/tools/zlib_mt_perf.c
@@ -218,8 +218,10 @@ static int defl(struct thread_data *d, FILE *source, int level)
 		return Z_ERRNO;
 
 	out = __malloc(CHUNK_o);
-	if (out == NULL)
+	if (out == NULL) {
+		__free(in);
 		return Z_ERRNO;
+	}
 
 	/* allocate deflate state */
 	strm.zalloc = Z_NULL;
@@ -319,8 +321,10 @@ static int infl(struct thread_data *d, FILE *source)
 		return Z_ERRNO;
 
 	out = __malloc(CHUNK_o);
-	if (out == NULL)
+	if (out == NULL) {
+		__free(in);
 		return Z_ERRNO;
+	}
 
 	/* allocate inflate state */
 	strm.zalloc = Z_NULL;
